{
  "name": "clustr-node",
  "version": "0.14.0",
  "description": "CoffeeScript cluster module to manage multi process cluster in NodeJs. Clustr is responseable for worker spawning and messaging between all processes.",
  "author": {
    "name": "Tim Schindler"
  },
  "keywords": [
    "multi",
    "process",
    "cluster",
    "coffeescript",
    "nodejs"
  ],
  "dependencies": {
    "redis": "0.8.3",
    "coffee-script": "1.3.3",
    "underscore": "1.4.2",
    "optimist": "0.3.4"
  },
  "devDependencies": {
    "jasmine-node": "1.9.1"
  },
  "engines": {
    "node": ">= 0.8.8"
  },
  "scripts": {
    "test": "node ./node_modules/jasmine-node/bin/jasmine-node --coffee spec/"
  },
  "readme": "[![Build Status](https://travis-ci.org/zyndiecate/clustr-node.png)](https://travis-ci.org/zyndiecate/clustr-node)\n\n\n\n# clustr-node\n\n\n\n## facts\n\n- each worker register to the cluster on process start\n- each worker deregister from the cluster on process end\n- each worker is able to spawn new processes\n- each worker is able to talk with each cluster member\n- each worker is able to kill workers\n- each worker is able to fetch cluster info\n- each worker respawns by default\n- each worker has a stats object containing event statistics of its own process\n- each worker knows the `pid` of the master process\n- cluster reloads when master receives `SIGHUP` (exit code 1)\n- cluster dies when master receives `SIGTERM` (exit code 15)\n- cluster dies when master receives signal from [emitKill](https://github.com/zyndiecate/clustr-node#emitkill)\n\n\n\n## install\n\n```bash\nnpm install clustr-node\n```\n\n\n\n## dependencies\n\n- `clustr` uses [pubsub](http://redis.io/topics/pubsub) for ipc, so you have to run a `redis` server on your machine.\n- `clustr` uses [taskset](http://www.unix.com/man-page/Linux/1/taskset/) for cpu affinity, so `clustr` should be used on `unix` systems.\n\n\n\n## usage\n\n### require\n\nTo require the module, just do.\n```coffeescript\nClustr = require(\"clustr-node\")\n```\n\n\n\n### create\n\nCreate a master process.\n```coffeescript\nmaster = Clustr.Master.create(options = {})\n```\n\n\n\nCreate a worker process.\n```coffeescript\nworker = Clustr.Worker.create\n  group: \"worker\"\n```\n\n\n\n### master options\n- reloadDelay\n\n\n\n### worker options\n- group\n\n\n\n### general options\n- logger\n- publisher\n- subscriber\n\n\n\n### groups\n\nWorkers can be in every possible group you can imagine. There is just one\nspecial group. The `master` group. Also there may should be only one worker\nin the `master` group.\n\n\n\n### onPublic\n\nPublic messages are send to each living process. To make a worker listen to\nmessages from the `public` channel do.\n```coffeescript\nworker.onPublic (message) =>\n  # do something with public message when it was received\n```\n\n\n\n### onPrivate\n\nPrivate messages are for a specific worker only that is identified by its\n`pid` property. To make a worker listen to private messages do.\n```coffeescript\nworker.onPrivate (message) =>\n  # do something with private message when it was received\n```\n\n\n\n### onGroup\n\nGroup messages are for a specific group only that is defined by its `group`\nproperty. To make a worker listen to group messages do.\n```coffeescript\nworker.onGroup (message) =>\n  # do something with group message when it was received\n```\n\n\n\n### onKill\n\nBefore a worker dies, it is possible to do something before. Here it is\nnecessary to execute the `cb` given to the `onKill` method. If the callback is\nnot fired, the process will __not__ die. To let a worker do his last action\nbefor death do.\n```coffeescript\nworker.onKill (cb) =>\n  # process last actions befor death\n  cb()\n```\n\n\n\n### onConfirmation\n\nWorker are able to receive confirmations. To listen to a confirmation just do\nthe following. As described, the callback is executed when the message\n\"identifier\" was received 2 times. Also, `messages` provided by the callback\ncontains meta data of all confirmed workers.\n```coffeescript\nworker.onConfirmation 2, \"identifier\", (messages) =>\n  # do something when messages \"identifier\" was received 2 times\n```\n\n\n\n### emitPublic\n\nTo make a worker publish a public message do.\n```coffeescript\nworker.emitPublic(\"message\")\n```\n\n\n\n### emitPrivate\n\nTo make a worker publish a private message do.\n```coffeescript\nworker.emitPrivate(\"pid\", \"message\")\n```\n\n\n\n### emitGroup\n\nTo make a worker publish a group message do.\n```coffeescript\nworker.emitGroup(\"group\", \"message\")\n```\n\n\n\n### emitKill\n\nEach process is able to kill another. For that action you need to know the\nunique `pid` of the worker you want to kill. `pid` here __is__\nthe systems `pid`. Each valid `exitCode`, a process respects, can be send\n(0, 1, etc.). `exitCode` defaults to 0. Killing a worker will terminate its\nchildren too. So be careful by sending a kill signal to the master process.\nThat will terminate the whole cluster. To send an exit code to an worker do.\n```coffeescript\nworker.emitKill(\"pid\", 0)\n```\n\n\n\n### emitConfirmation\n\nTo make a worker publish a confirmation message do.\n```coffeescript\nworker.emitConfirmation(\"message\")\n```\n\n\n\n### emitClusterInfo\n\nWorkers are able to receive cluster infos like that. See also the\n[clusterInfo](https://github.com/zyndiecate/clustr-node#clusterinfo) section.\n```coffeescript\nwebWorkerChild.emitClusterInfo (message) =>\n  # do something with cluster info when it was received\n```\n\n\n\n### spawn\n\nEach process is able to spawn workers.\n\nrequired:\n- `file` defines the file a worker should execute.\n\noptional:\n- `cpu` set cpu affinity using the `taskset` command, which **only works under unix systems**.\n- `command` defines the command that executes `file`. By default `file` will be executed using the parents execution command.\n- `respawn` by default is set to `true`. To prevent respawning a worker set `respawn` to `false`.\n- `args` an object of command line args that will be given to a process.\n\nTo make a worker spawn workers, do something like that.\n```coffeescript\nworker.spawn [\n  { file: \"./web_worker.coffee\",   cpu: 0 }\n  { file: \"./web_worker.coffee\",   cpu: 1, args: { \"cluster-option\": \"foo\", private: \"option\" } }\n  { file: \"./cache_worker.coffee\", cpu: 2, respawn: false }\n  { file: \"./cache_worker.coffee\", cpu: 3, respawn: false }\n  { file: \"./bashscript\", command: \"bash\" }\n]\n```\n\n\n\n### close\n\nIt is possible to close a worker using a given `exitCode`, that defaults to 1.\nThat means the worker respawns by default. Sending `exitCode` 0 let the worker\ndieing if `respawn` is set to `false`. Closing a worker means the following.\n- The worker will be deregistered from the cluster.\n- All connections will be closed.\n- All listeners will be removed.\n- The process exits with the given `exitCode` or 1.\n\n```coffeescript\nworker.close(1)\n```\n\n\n\n### masterPid\n\nThe master process id is available for each worker. It will be bubbled through\nthe cluster. So all workers are always able to talk with the master like that.\n```coffeescript\nworker.emitPrivate(worker.masterPid, \"message\")\n```\n\n\n\n### reloading\n\nReloading the cluster enables zero downtime deployments. One worker after\nanother is forced to be killed and reloaded, delayed by `reloadDelay`.\n- do `kill -s SIGTERM masterpid` to kill cluster\n- do `kill -s SIGHUP masterpid` to reload cluster\n- `reloadDelay` delays reloading single workers to enable buffering, defaults to 500ms\n\n\n\n### messages\n\nIf a process receives a message it looks something like that. Each meta item\nshould be a string. The data you send can be whatever is stringifyable. So you\nwill be able to receive what you send. Note that confirmation messages should\nonly be simple strings.\n```coffeescript\nmessage =\n  meta:\n    pid:   PROCESS_ID\n    group: GROUP\n  data:    YOUR_MESSAGE\n```\n\n\n\n### stats\n\nEach worker has a stats object containing event statistics with the following\nproperties.\n- `emitPublic`\n- `emitPrivate`\n- `emitGroup`\n- `emitKill`\n- `emitConfirmation`\n- `onMessage`\n- `onPublic`\n- `onGroup`\n- `onPrivate`\n- `spawnChildProcess`\n- `respawnChildProcess`\n- `receivedConfirmations`\n- `successfulConfirmations`\n\n\n\n### clusterInfo\n\nThe `clusterInfo` object could look something like that. It contains lists of\ncluster process ids grouped by the current cluster group names.\n```coffeescript\nclusterInfo =\n  webWorker:   [ 5182, 5184 ]\n  cacheWorker: [ 5186, 5188 ]\n```\n\n\n\n### argv\n\nCommand line argument parsing is realized using the\n[optimist](https://github.com/substack/node-optimist) library. Arguments by\ndefault are used by the given process. To bubble arguments through each process\nof the cluster, prefix command line options with `cluster-`. See the\n[examples](https://github.com/zyndiecate/clustr-node#examples) section, where\n`--cluster-verbose` is given to each spawned child process, to enable logging\nfor the whole cluster. So, if you start the cluster just using `--verbose`,\nonly the master is able to log. Also, if you set a cluster option to a spawned\nworker definition using the `args` property, each children of that worker will\nreceive that option too.\n\n\n\n### logging\n\nBy default the cluster do not log any information. To make the master log its\nown output, add `--verbose` to the execution command. To enable logging for the\nwhole cluster, add `--cluster-verbose` to the execution command.\n\n\n\n### examples\n\nFor examples take a look into the `examples/` directory and play around.\n```bash\ncoffee examples/reload/master.coffee --cluster-verbose\ncoffee examples/messaging/master.coffee --cluster-verbose\n```\n\n\n\n### tests\n\nTests are located in `spec/` directory. To run it just do.\n```bash\nnpm test\n```\n",
  "_id": "clustr-node@0.14.0",
  "dist": {
    "shasum": "97d2ea80c8c233dd6b8226c260a478965e37b588"
  },
  "_from": "clustr-node@0.14.0"
}
